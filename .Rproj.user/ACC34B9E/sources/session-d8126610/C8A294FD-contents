# ==============================================================================
# SIR Model Estimation Comparison Shiny Application
#
# Version: Final Polished UI
#
# This application compares three parameter estimation methods (Least Squares,
# Bootstrap, and Metropolis-Hastings) for the Susceptible-Infected-Recovered
# (SIR) model. It simultaneously analyzes two real-world datasets:
# 1. Measles data from Niamey, Niger.
# 2. COVID-19 data from the United States.
#
# --- KEY WORKFLOW ---
# 1. PARAMETER SETUP: The user can adjust parameters for both models in the
#    purple (Measles) and orange (COVID-19) boxes. This includes initial
#    guesses for the SIR parameters (beta, gamma) and settings for the
#    Bootstrap (B) and MCMC (M, M_burnin) methods.
#
# 2. ANALYSIS EXECUTION: Clicking "Add Records & Run Analysis" triggers two
#    parallel background analyses using the 'promises' and 'future' packages.
#    This keeps the UI responsive during computation.
#
# 3. ESTIMATION PIPELINE (for each dataset):
#    a. Least Squares (LS): A fast optimization is run to find a good initial
#       parameter estimate.
#    b. Bootstrap: Multiple new datasets are created by resampling the original
#       data. The LS estimate is used as a smart starting point for optimization
#       on each new dataset. To ensure robustness, the top and bottom 1% of
#       these bootstrap results are treated as outliers and removed.
#    c. Metropolis-Hastings (MCMC): A Markov chain is run to explore the
#       posterior distribution of the parameters, also starting from the
#       LS estimate.
#
# 4. RESULTS VISUALIZATION: Once analyses are complete, the UI updates:
#    - The "Analysis Records" table is populated with the main parameter estimates.
#    - The "Results" boxes display four plots for each dataset:
#      - Fit Comparison: Shows observed data against the fitted curves from all three methods.
#      - MCMC Trace: Visualizes the MCMC chain's path, with a line indicating the burn-in period.
#      - MH Posterior: A histogram showing the distribution of the MCMC samples after burn-in.
#      - Bootstrap Distribution: A smooth density plot showing the distribution of the cleaned bootstrap samples.
# ==============================================================================

# 1. LOAD PACKAGES
library(shiny)
library(shinydashboard)
library(DT)
library(plotly)
library(deSolve)
library(ggplot2)
library(dplyr)
library(readr)
library(lubridate)
library(zoo)
library(tidyr)
library(promises)
library(future)
plan(multisession)

# 2. UI HELPER
param_input_factory <- function(inputId, label_symbol, tooltip_text, value, min, max, step) {
  div(style = "display: flex; align-items: center; margin-bottom: 5px;", div(style = "width: 50%;", tags$label(HTML(label_symbol), style = "margin-right: 5px;"), shiny::icon("info-circle", title = tooltip_text, style = "color: #007bff; cursor: help;")), div(style = "width: 50%;", numericInput(inputId, label = NULL, value = value, min = min, max = max, step = step)))
}

# 3. UI
ui <- dashboardPage(
  dashboardHeader(title = "SIR Model Estimation", titleWidth = 250),
  dashboardSidebar(width = 250, sidebarMenu(menuItem("Dashboard", tabName = "dashboard", icon = icon("dashboard")), menuItem("Model Description", tabName = "model_desc", icon = icon("info-circle")))),
  dashboardBody(
    # CSS block with all requested UI changes
    tags$head(tags$style(HTML("
      /* Req 3: Main header bar to grey */
      .skin-blue .main-header .navbar,
      .skin-blue .main-header .logo {
        background-color: #6c757d !important;
      }
      /* Req 2: Orange parameter box to match trial comparison app */
      .box.box-solid.box-warning { border-color: #f0ad4e; }
      .box.box-solid.box-warning > .box-header { background: #f0ad4e; color: #ffffff; }
      
      /* Standard purple for measles parameter box */
      .box.box-solid.box-primary { border-color: #6f42c1; }
      .box.box-solid.box-primary > .box-header { background: #6f42c1; color: #ffffff; }

      /* Req 4: Lighter result box headers */
      .box.box-primary:not(.box-solid) > .box-header { background-color: #f2e8f9; } /* Light purple */
      .box.box-warning:not(.box-solid) > .box-header { background-color: #fce5d4; } /* Light orange */
      
      /* Req 3: Smaller, centered purple action button */
      .center-btn-wrapper { text-align: center; padding-top: 15px; padding-bottom: 15px; }
      #add_record {
        color: #fff;
        background-color: #6f42c1; /* Purple */
        border-color: #6f42c1;
      }
    "))),
    tabItems(
      tabItem(tabName = "dashboard",
              fluidRow(
                box(title = "Measles Parameters Setting", status = "primary", solidHeader = TRUE, collapsible = TRUE, width = 6, param_input_factory("N_0_m", "N_0:", "Total population size", 3500, 3000, 4000, 100), param_input_factory("beta_0_m", "&beta;<sub>0</sub>:", "Initial transmission rate", 0.2, 0.05, 0.55, 0.01), param_input_factory("gamma_0_m", "&gamma;<sub>0</sub>:", "Initial recovery rate", 0.21, 0.05, 0.55, 0.01), param_input_factory("B_m", "B:", "Bootstrap sample size", 300, 50, 1000, 10), param_input_factory("M_m", "M:", "Iteration times of MH", 3000, 500, 100000, 1000), param_input_factory("M_burnin_m", "M_burnin:", "Burn-in period for MCMC", 2000, 100, 10000, 500), param_input_factory("sd_beta_m", "SD_&beta;:", "Proposal SD for &beta; in MH", 0.014, 0.001, 0.1, 0.001), param_input_factory("sd_gamma_m", "SD_&gamma;:", "Proposal SD for &gamma; in MH", 0.014, 0.001, 0.1, 0.001)),
                box(title = "COVID-19 Parameters Setting", status = "warning", solidHeader = TRUE, collapsible = TRUE, width = 6, param_input_factory("N_0_c", "N_0:", "Total population size (in 10k)", 32800, 32000, 36000, 100), param_input_factory("beta_0_c", "&beta;<sub>0</sub>:", "Initial transmission rate", 0.2, 0.05, 0.55, 0.01), param_input_factory("gamma_0_c", "&gamma;<sub>0</sub>:", "Initial recovery rate", 0.01, 0.01, 0.55, 0.01), param_input_factory("B_c", "B:", "Bootstrap sample size", 300, 50, 1000, 10), param_input_factory("M_c", "M:", "Iteration times of MH", 3000, 500, 100000, 1000), param_input_factory("M_burnin_c", "M_burnin:", "Burn-in period for MCMC", 2000, 100, 10000, 500), param_input_factory("sd_beta_c", "SD_&beta;:", "Proposal SD for &beta; in MH", 0.01, 0.001, 0.1, 0.001), param_input_factory("sd_gamma_c", "SD_&gamma;:", "Proposal SD for &gamma; in MH", 0.01, 0.001, 0.1, 0.001))
              ),
              div(class = "center-btn-wrapper",
                  actionButton("add_record", "Add Records & Run Analysis", icon = icon("plus"))
              ),
              fluidRow(box(title = "Analysis Records", status = "primary", solidHeader = FALSE, width = 12, collapsible = TRUE, DT::dataTableOutput("parameter_records"))),
              fluidRow(
                column(width = 6, box(title = "Measles Results", status = "primary", solidHeader = FALSE, width = NULL, tabsetPanel(id = "measles_tabs", tabPanel("Fit Comparison", plotlyOutput("measles_fit_plot", height = "350px")), tabPanel("MCMC Trace", plotlyOutput("measles_mcmc_trace", height = "350px")), tabPanel("MH Posterior", plotlyOutput("measles_mh_posterior", height = "350px")), tabPanel("Bootstrap Distribution", plotlyOutput("measles_bs_dist", height = "350px"))))),
                column(width = 6, box(title = "COVID-19 Results", status = "warning", solidHeader = FALSE, width = NULL, tabsetPanel(id = "covid_tabs", tabPanel("Fit Comparison", plotlyOutput("covid_fit_plot", height = "350px")), tabPanel("MCMC Trace", plotlyOutput("covid_mcmc_trace", height = "350px")), tabPanel("MH Posterior", plotlyOutput("covid_mh_posterior", height = "350px")), tabPanel("Bootstrap Distribution", plotlyOutput("covid_bs_dist", height = "350px")))))
              )
      ),
      tabItem(tabName = "model_desc", fluidRow(box(title = "SIR Model Description", status = "primary", solidHeader = TRUE, width = 12, h3("Susceptible-Infected-Recovered (SIR) Model"), p("The SIR model is a compartmental epidemiological model..."), withMathJax(), p("$$\\frac{dS}{dt} = -\\beta \\frac{SI}{N}$$"), p("$$\\frac{dI}{dt} = \\beta \\frac{SI}{N} - \\gamma I$$"), p("$$\\frac{dR}{dt} = \\gamma I$$"))))
    )
  )
)

# 4. SERVER
server <- function(input, output, session) {
  values <- reactiveValues(records = data.frame(), measles_results = NULL, covid_results = NULL)
  measles_data <- reactive({ read_csv("http://kingaa.github.io/clim-dis/parest/niamey.csv", show_col_types = FALSE, progress = FALSE) %>% filter(community == "A") %>% select(time = biweek, cases = measles) %>% arrange(time) })
  covid_data <- reactive({ jhu_url <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_US.csv"; read_csv(jhu_url, show_col_types = FALSE, progress = FALSE) %>% select(-c(UID, iso2, iso3, code3, FIPS, Admin2, Province_State, Country_Region, Lat, Long_, Combined_Key)) %>% pivot_longer(cols = matches("^\\d+/\\d+/\\d+$"), names_to = "Date", values_to = "Cumulative_Cases") %>% mutate(Date = mdy(Date)) %>% group_by(Date) %>% summarise(Cumulative_Cases = sum(Cumulative_Cases, na.rm = TRUE), .groups = 'drop') %>% arrange(Date) %>% mutate(Daily_New_Cases = Cumulative_Cases - lag(Cumulative_Cases, default = 0)) %>% filter(Daily_New_Cases >= 0, Date >= as.Date("2020-01-22")) %>% mutate(Active_Cases = zoo::rollsum(Daily_New_Cases, k = 14, fill = NA, align = "right")) %>% filter(!is.na(Active_Cases)) %>% mutate(Days_Since_Start = as.numeric(Date - min(Date)), Biweek_Group = floor(Days_Since_Start / 14)) %>% group_by(Biweek_Group) %>% summarise(cases = round(mean(Active_Cases, na.rm = TRUE) / 10000), .groups = 'drop') %>% filter(Biweek_Group >= 0, cases > 0) %>% mutate(time = Biweek_Group + 1) %>% select(time, cases) %>% arrange(time) %>% filter(time <= 35) })
  observe({ updateNumericInput(session, "M_burnin_m", max = input$M_m - 100); updateNumericInput(session, "M_burnin_c", max = input$M_c - 100) })
  run_full_analysis <- function(data, params) {
    sir_model <- function(time, state, parameters) { with(as.list(c(state, parameters)), { N_total <- S + I + R; dS <- -beta * S * I / N_total; dI <- beta * S * I / N_total - gamma * I; dR <- gamma * I; list(c(dS, dI, dR)) }) }
    SOLVER_METHOD <- "rk4"
    ls_objective <- function(p) { init <- c(S = params$N - 1, I = 1, R = 0); sol <- deSolve::ode(y = init, times = data$time, func = sir_model, parms = list(beta = p[1], gamma = p[2]), method = SOLVER_METHOD); sum((data$cases - sol[, "I"])^2, na.rm = TRUE) }
    ls_result <- optim(par = c(params$beta_0, params$gamma_0), fn = ls_objective, method = "L-BFGS-B", lower = c(0.001, 0.001)); ls_fit <- list(beta = ls_result$par[1], gamma = ls_result$par[2])
    smart_initial_params <- c(ls_fit$beta, ls_fit$gamma)
    bs_samples <- matrix(NA, nrow = params$B, ncol = 2); colnames(bs_samples) <- c("beta", "gamma")
    for (i in 1:params$B) { bs_data <- data[sample(1:nrow(data), replace = TRUE), ]; bs_objective <- function(p) { init <- c(S = params$N - 1, I = 1, R = 0); sol <- deSolve::ode(y = init, times = bs_data$time, func = sir_model, parms = list(beta = p[1], gamma = p[2]), method = SOLVER_METHOD); sum((bs_data$cases - sol[, "I"])^2, na.rm = TRUE) }; bs_res <- try(optim(par = smart_initial_params, fn = bs_objective, method = "L-BFGS-B", lower = c(0.001, 0.001)), silent = TRUE); if (!inherits(bs_res, "try-error")) bs_samples[i, ] <- bs_res$par }
    bs_samples_raw <- na.omit(bs_samples)
    if (nrow(bs_samples_raw) > 10) { q_beta <- quantile(bs_samples_raw[, 1], probs = c(0.01, 0.99), na.rm = TRUE); q_gamma <- quantile(bs_samples_raw[, 2], probs = c(0.01, 0.99), na.rm = TRUE); good_indices <- which(bs_samples_raw[, 1] >= q_beta[1] & bs_samples_raw[, 1] <= q_beta[2] & bs_samples_raw[, 2] >= q_gamma[1] & bs_samples_raw[, 2] <= q_gamma[2]); bs_samples_cleaned <- bs_samples_raw[good_indices, , drop = FALSE] } else { bs_samples_cleaned <- bs_samples_raw }
    bs_fit <- list(beta_mean = mean(bs_samples_cleaned[, 1]), gamma_mean = mean(bs_samples_cleaned[, 2]), samples = bs_samples_cleaned)
    log_likelihood <- function(p) { init <- c(S = params$N - 1, I = 1, R = 0); sol <- try(deSolve::ode(y = init, times = data$time, func = sir_model, parms = list(beta = p[1], gamma = p[2]), method = SOLVER_METHOD), silent = TRUE); if (inherits(sol, "try-error") || any(sol[, "I"] <= 0)) return(-Inf); sum(dpois(data$cases, lambda = sol[, "I"], log = TRUE), na.rm = TRUE) }
    mh_chain <- matrix(NA, nrow = params$M, ncol = 2); colnames(mh_chain) <- c("beta", "gamma"); mh_chain[1, ] <- smart_initial_params; current_log_lik <- log_likelihood(mh_chain[1, ])
    for (i in 2:params$M) { proposal <- mh_chain[i-1, ] + rnorm(2, 0, c(params$sd_beta, params$sd_gamma)); if (any(proposal <= 0)) { mh_chain[i, ] <- mh_chain[i-1, ]; next }; proposal_log_lik <- log_likelihood(proposal); if (is.finite(proposal_log_lik) && is.finite(current_log_lik) && runif(1) < exp(proposal_log_lik - current_log_lik)) { mh_chain[i, ] <- proposal; current_log_lik <- proposal_log_lik } else { mh_chain[i, ] <- mh_chain[i-1, ] } }
    mh_post_burn <- mh_chain[(params$M_burnin + 1):params$M, ]; mh_fit <- list(beta_mean = mean(mh_post_burn[, 1]), gamma_mean = mean(mh_post_burn[, 2]), full_chain = mh_chain, post_burn_chain = mh_post_burn, M_burnin = params$M_burnin)
    time_seq <- seq(min(data$time), max(data$time), length.out = 100); init_state <- c(S = params$N - 1, I = 1, R = 0); n_viz_samples <- 100
    if (nrow(bs_fit$samples) > 0) { bs_viz_samples <- bs_fit$samples[sample(nrow(bs_fit$samples), min(n_viz_samples, nrow(bs_fit$samples))), , drop = FALSE]; bs_pred_curves <- apply(bs_viz_samples, 1, function(p) deSolve::ode(y = init_state, times = time_seq, func = sir_model, parms = list(beta = p[1], gamma = p[2]), method = SOLVER_METHOD)[, "I"]); bs_ci_curves <- t(apply(bs_pred_curves, 1, quantile, probs = c(0.025, 0.975), na.rm = TRUE)) } else { bs_ci_curves <- matrix(0, nrow=length(time_seq), ncol=2) }
    mh_viz_samples <- mh_post_burn[sample(nrow(mh_post_burn), min(n_viz_samples, nrow(mh_post_burn))), , drop = FALSE]; mh_pred_curves <- apply(mh_viz_samples, 1, function(p) deSolve::ode(y = init_state, times = time_seq, func = sir_model, parms = list(beta = p[1], gamma = p[2]), method = SOLVER_METHOD)[, "I"]); mh_ci_curves <- t(apply(mh_pred_curves, 1, quantile, probs = c(0.025, 0.975), na.rm = TRUE))
    list(ls = ls_fit, bs = bs_fit, mh = mh_fit, curves = list(time = time_seq, ls_I = deSolve::ode(y = init_state, times = time_seq, func = sir_model, parms = ls_fit, method = SOLVER_METHOD)[, "I"], bs_I_mean = deSolve::ode(y = init_state, times = time_seq, func = sir_model, parms = list(beta=bs_fit$beta_mean, gamma=bs_fit$gamma_mean), method = SOLVER_METHOD)[, "I"], mh_I_mean = deSolve::ode(y = init_state, times = time_seq, func = sir_model, parms = list(beta=mh_fit$beta_mean, gamma=mh_fit$gamma_mean), method = SOLVER_METHOD)[, "I"], bs_I_low = bs_ci_curves[, 1], bs_I_high = bs_ci_curves[, 2], mh_I_low = mh_ci_curves[, 1], mh_I_high = mh_ci_curves[, 2]))
  }
  observeEvent(input$add_record, {
    # Req 1: Persistent notification
    id <- showNotification("Analysis started in background... Please wait.", duration = NULL, type = "message", closeButton = FALSE)
    on.exit(removeNotification(id), add = TRUE)
    measles_params <- list(N = input$N_0_m, beta_0 = input$beta_0_m, gamma_0 = input$gamma_0_m, B = input$B_m, M = input$M_m, M_burnin = input$M_burnin_m, sd_beta = input$sd_beta_m, sd_gamma = input$sd_gamma_m)
    covid_params <- list(N = input$N_0_c, beta_0 = input$beta_0_c, gamma_0 = input$gamma_0_c, B = input$B_c, M = input$M_c, M_burnin = input$M_burnin_c, sd_beta = input$sd_beta_c, sd_gamma = input$sd_gamma_c)
    m_data <- measles_data(); c_data <- covid_data()
    future_measles <- future({ run_full_analysis(m_data, measles_params) }, packages = c("deSolve", "dplyr"), seed = TRUE)
    future_covid   <- future({ run_full_analysis(c_data, covid_params) }, packages = c("deSolve", "dplyr"), seed = TRUE)
    promise_all(m = future_measles, c = future_covid) %...>% 
      (function(results) {
        values$measles_results <- results$m; values$covid_results <- results$c
        new_measles_record <- data.frame(Dataset = "Measles", LS_Beta = round(results$m$ls$beta, 4), LS_Gamma = round(results$m$ls$gamma, 4), BS_Beta = round(results$m$bs$beta_mean, 4), BS_Gamma = round(results$m$bs$gamma_mean, 4), MH_Beta = round(results$m$mh$beta_mean, 4), MH_Gamma = round(results$m$mh$gamma_mean, 4))
        new_covid_record <- data.frame(Dataset = "COVID-19", LS_Beta = round(results$c$ls$beta, 4), LS_Gamma = round(results$c$ls$gamma, 4), BS_Beta = round(results$c$bs$beta_mean, 4), BS_Gamma = round(results$c$bs$gamma_mean, 4), MH_Beta = round(results$c$mh$beta_mean, 4), MH_Gamma = round(results$c$mh$gamma_mean, 4))
        values$records <- rbind(values$records, new_measles_record, new_covid_record)
        showNotification("Analysis complete! Results updated.", type = "success", duration = 5)
      }) %...>%
      catch(function(error) { showNotification(paste("Error during analysis:", error$message), type = "error", duration = NULL); print(error) })
    return(NULL)
  })
  output$parameter_records <- DT::renderDataTable({ req(nrow(values$records) > 0); DT::datatable(values$records, selection = 'none', rownames = TRUE, options = list(scrollX = TRUE, pageLength = 4)) })
  
  # Req 5: Shared plot title styles
  title_style <- list(y = 0.95, x = 0.05, xanchor = 'left', yanchor = 'top', font = list(size = 14))
  
  render_fit_plot <- function(results, data, title) {
    req(results, data); curves <- results$curves
    p <- plot_ly(source = title) %>% 
      add_markers(data = data, x = ~time, y = ~cases, name = "Observed", marker = list(color = "black", symbol = 'circle', size = 6)) %>% 
      add_polygons(x = ~c(curves$time, rev(curves$time)), y = ~c(curves$bs_I_high, rev(curves$bs_I_low)), fillcolor = 'rgba(69, 117, 180, 0.2)', line = list(width = 0), name = 'Bootstrap 95% CI', showlegend = TRUE) %>% 
      add_polygons(x = ~c(curves$time, rev(curves$time)), y = ~c(curves$mh_I_high, rev(curves$mh_I_low)), fillcolor = 'rgba(145, 191, 219, 0.2)', line = list(width = 0), name = 'MH 95% CI', showlegend = TRUE) %>% 
      add_lines(x = curves$time, y = curves$ls_I, name = "Least Squares", line = list(color = '#d73027', width = 2)) %>% 
      add_lines(x = curves$time, y = curves$bs_I_mean, name = "Bootstrap Mean", line = list(color = '#4575b4', width = 2, dash = 'dash')) %>% 
      add_lines(x = curves$time, y = curves$mh_I_mean, name = "MH Mean", line = list(color = '#91bfdb', width = 2, dash = 'dot')) %>% 
      layout(title = list(text = title, y = title_style$y, x = title_style$x, xanchor = title_style$xanchor, yanchor = title_style$yanchor, font = title_style$font), xaxis = list(title = "Time (Bi-weeks)"), yaxis = list(title = "Cases"), legend = list(orientation = "h", xanchor = "center", x = 0.5, y = -0.3))
    return(p)
  }
  render_mcmc_trace <- function(results, title) {
    req(results); chain <- as.data.frame(results$mh$full_chain); chain$Iteration <- 1:nrow(chain); burnin_val <- results$mh$M_burnin
    p1 <- plot_ly(data = chain, x = ~Iteration, y = ~beta, type = 'scatter', mode = 'lines', name = "&beta;", line = list(color = '#2b83ba'))
    p2 <- plot_ly(data = chain, x = ~Iteration, y = ~gamma, type = 'scatter', mode = 'lines', name = "&gamma;", line = list(color = '#fdae61'))
    p <- subplot(p1, p2, nrows = 2, shareX = TRUE, titleY = TRUE) %>% 
      layout(title = list(text = title, y = title_style$y, x = title_style$x, xanchor = title_style$xanchor, yanchor = title_style$yanchor, font = title_style$font), showlegend = FALSE, shapes = list(list(type = 'line', x0 = burnin_val, x1 = burnin_val, y0 = 0, y1 = 1, yref = 'paper', line = list(color = 'red', dash = 'dot', width = 2))), annotations = list(x = burnin_val, y = 1.05, yref = "paper", text = "Burn-in", showarrow = FALSE))
    return(p)
  }
  render_mh_posterior <- function(results, title) {
    req(results); chain <- as.data.frame(results$mh$post_burn_chain)
    p1 <- plot_ly(data = chain, x = ~beta, type = 'histogram', name = "&beta;", marker = list(color = '#91bfdb'))
    p2 <- plot_ly(data = chain, x = ~gamma, type = 'histogram', name = "&gamma;", marker = list(color = '#91bfdb'))
    p <- subplot(p1, p2, nrows = 2, titleY = TRUE) %>% 
      layout(title = list(text = title, y = title_style$y, x = title_style$x, xanchor = title_style$xanchor, yanchor = title_style$yanchor, font = title_style$font), showlegend = FALSE, xaxis = list(title = "&beta;"), xaxis2 = list(title = "&gamma;"))
    return(p)
  }
  render_bs_dist <- function(results, title) {
    req(results); samples <- as.data.frame(results$bs$samples); main_color <- '#4575b4'; fill_color <- 'rgba(69, 117, 180, 0.4)'
    if (nrow(samples) < 3) { return(plot_ly() %>% layout(title = title, annotations = list(text = "Not enough data for plot."))) }
    d_beta <- density(samples$beta, na.rm = TRUE)
    p1 <- plot_ly(x = ~d_beta$x, y = ~d_beta$y, type = 'scatter', mode = 'lines', fill = 'tozeroy', fillcolor = fill_color, line = list(color = main_color), name = "&beta;") %>% layout(xaxis = list(title = "&beta;"), yaxis = list(title = "Density"))
    d_gamma <- density(samples$gamma, na.rm = TRUE)
    p2 <- plot_ly(x = ~d_gamma$x, y = ~d_gamma$y, type = 'scatter', mode = 'lines', fill = 'tozeroy', fillcolor = fill_color, line = list(color = main_color), name = "&gamma;") %>% layout(xaxis = list(title = "&gamma;"), yaxis = list(title = "Density"))
    p <- subplot(p1, p2, nrows = 2, shareY = TRUE, titleY = TRUE) %>% 
      layout(title = list(text = title, y = title_style$y, x = title_style$x, xanchor = title_style$xanchor, yanchor = title_style$yanchor, font = title_style$font), showlegend = FALSE)
    return(p)
  }
  
  output$measles_fit_plot <- renderPlotly({ render_fit_plot(values$measles_results, measles_data(), "Fit Comparison (Measles)") })
  output$measles_mcmc_trace <- renderPlotly({ render_mcmc_trace(values$measles_results, "MCMC Trace (Measles)") })
  output$measles_mh_posterior <- renderPlotly({ render_mh_posterior(values$measles_results, "MH Posterior (Measles)") })
  output$measles_bs_dist <- renderPlotly({ render_bs_dist(values$measles_results, "Bootstrap Distribution (Measles)") })
  output$covid_fit_plot <- renderPlotly({ render_fit_plot(values$covid_results, covid_data(), "Fit Comparison (COVID-19)") })
  output$covid_mcmc_trace <- renderPlotly({ render_mcmc_trace(values$covid_results, "MCMC Trace (COVID-19)") })
  output$covid_mh_posterior <- renderPlotly({ render_mh_posterior(values$covid_results, "MH Posterior (COVID-19)") })
  output$covid_bs_dist <- renderPlotly({ render_bs_dist(values$covid_results, "Bootstrap Distribution (COVID-19)") })
}

# 5. RUN
shinyApp(ui = ui, server = server)