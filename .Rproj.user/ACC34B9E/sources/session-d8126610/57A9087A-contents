# ==============================================================================
# SIR Model Estimation Comparison Shiny Application
# FINAL OPTIMIZED VERSION for shinyapps.io free tier
#
# Changes:
# 1. Switched ODE solver to "rk4" for significant speed improvement.
# 2. Drastically reduced default values for B and M to fit within timeout.
# ==============================================================================

library(shiny)
library(shinydashboard)
library(DT)
library(plotly)
library(deSolve)
library(ggplot2)
library(dplyr)
library(readr)
library(lubridate)
library(zoo)
library(tidyr)
library(promises)
library(future)

plan(multisession)

# UI HELPER
param_input_factory <- function(inputId, label_symbol, tooltip_text, value, min, max, step) {
  div(style = "display: flex; align-items: center; margin-bottom: 5px;", div(style = "width: 50%;", tags$label(HTML(label_symbol), style = "margin-right: 5px;"), shiny::icon("info-circle", title = tooltip_text, style = "color: #007bff; cursor: help;")), div(style = "width: 50%;", numericInput(inputId, label = NULL, value = value, min = min, max = max, step = step)))
}

# UI
ui <- dashboardPage(
  dashboardHeader(title = "SIR Model Estimation", titleWidth = 250),
  dashboardSidebar(width = 250, sidebarMenu(menuItem("Dashboard", tabName = "dashboard", icon = icon("dashboard")), menuItem("Model Description", tabName = "model_desc", icon = icon("info-circle")))),
  dashboardBody(
    tags$head(tags$style(HTML(".content-wrapper { background-color: #f4f6f9 !important; } .box.box-solid.box-primary { border-color: #6f42c1; } .box.box-solid.box-primary > .box-header { background: #6f42c1; color: #ffffff; } .box.box-solid.box-warning { border-color: #fd7e14; } .box.box-solid.box-warning > .box-header { background: #fd7e14; color: #ffffff; } .center-btn { text-align: center; margin-top: 15px; margin-bottom: 15px; }"))),
    tabItems(
      tabItem(tabName = "dashboard",
              fluidRow(
                box(title = "Measles Parameters Setting", status = "primary", solidHeader = TRUE, collapsible = TRUE, width = 6, param_input_factory("N_0_m", "N_0:", "Total population size", 3500, 3000, 4000, 100), param_input_factory("beta_0_m", "&beta;<sub>0</sub>:", "Initial transmission rate", 0.2, 0.05, 0.55, 0.01), param_input_factory("gamma_0_m", "&gamma;<sub>0</sub>:", "Initial recovery rate", 0.21, 0.05, 0.55, 0.01), param_input_factory("B_m", "B:", "Bootstrap sample size", 100, 50, 1000, 1), param_input_factory("M_m", "M:", "Iteration times of MH", 2000, 500, 100000, 1000), param_input_factory("M_burnin_m", "M_burnin:", "Burn-in period for MCMC", 500, 100, 10000, 500), param_input_factory("sd_beta_m", "SD_&beta;:", "Proposal SD for &beta; in MH", 0.014, 0.001, 0.1, 0.001), param_input_factory("sd_gamma_m", "SD_&gamma;:", "Proposal SD for &gamma; in MH", 0.014, 0.001, 0.1, 0.001)),
                box(title = "COVID-19 Parameters Setting", status = "warning", solidHeader = TRUE, collapsible = TRUE, width = 6, param_input_factory("N_0_c", "N_0:", "Total population size (in 10k)", 32800, 32000, 36000, 100), param_input_factory("beta_0_c", "&beta;<sub>0</sub>:", "Initial transmission rate", 0.2, 0.05, 0.55, 0.01), param_input_factory("gamma_0_c", "&gamma;<sub>0</sub>:", "Initial recovery rate", 0.01, 0.01, 0.55, 0.01), param_input_factory("B_c", "B:", "Bootstrap sample size", 100, 50, 1000, 1), param_input_factory("M_c", "M:", "Iteration times of MH", 2000, 500, 100000, 1000), param_input_factory("M_burnin_c", "M_burnin:", "Burn-in period for MCMC", 500, 100, 10000, 500), param_input_factory("sd_beta_c", "SD_&beta;:", "Proposal SD for &beta; in MH", 0.01, 0.001, 0.1, 0.001), param_input_factory("sd_gamma_c", "SD_&gamma;:", "Proposal SD for &gamma; in MH", 0.01, 0.001, 0.1, 0.001))
              ),
              fluidRow(column(width = 12, class = "center-btn", actionButton("add_record", "Add Records & Run Analysis", icon = icon("play-circle"), class = "btn-success btn-lg"))),
              fluidRow(box(title = "Analysis Records", status = "primary", solidHeader = FALSE, width = 12, collapsible = TRUE, DT::dataTableOutput("parameter_records"))),
              fluidRow(
                column(width = 6, box(title = "Measles Results", status = "primary", solidHeader = FALSE, width = NULL, tabsetPanel(id = "measles_tabs", tabPanel("Fit Comparison", plotlyOutput("measles_fit_plot", height = "350px")), tabPanel("MCMC Trace", plotlyOutput("measles_mcmc_trace", height = "350px")), tabPanel("MH Posterior", plotlyOutput("measles_mh_posterior", height = "350px")), tabPanel("Bootstrap Distribution", plotlyOutput("measles_bs_dist", height = "350px"))))),
                column(width = 6, box(title = "COVID-19 Results", status = "warning", solidHeader = FALSE, width = NULL, tabsetPanel(id = "covid_tabs", tabPanel("Fit Comparison", plotlyOutput("covid_fit_plot", height = "350px")), tabPanel("MCMC Trace", plotlyOutput("covid_mcmc_trace", height = "350px")), tabPanel("MH Posterior", plotlyOutput("covid_mh_posterior", height = "350px")), tabPanel("Bootstrap Distribution", plotlyOutput("covid_bs_dist", height = "350px")))))
              )
      ),
      tabItem(tabName = "model_desc", fluidRow(box(title = "SIR Model Description", status = "primary", solidHeader = TRUE, width = 12, h3("Susceptible-Infected-Recovered (SIR) Model"), p("The SIR model is a compartmental epidemiological model..."), withMathJax(), p("$$\\frac{dS}{dt} = -\\beta \\frac{SI}{N}$$"), p("$$\\frac{dI}{dt} = \\beta \\frac{SI}{N} - \\gamma I$$"), p("$$\\frac{dR}{dt} = \\gamma I$$"))))
    )
  )
)

# SERVER
server <- function(input, output, session) {
  values <- reactiveValues(records = data.frame(), measles_results = NULL, covid_results = NULL)
  measles_data <- reactive({ read_csv("http://kingaa.github.io/clim-dis/parest/niamey.csv", show_col_types = FALSE) %>% filter(community == "A") %>% select(time = biweek, cases = measles) %>% arrange(time) })
  covid_data <- reactive({ jhu_url <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_US.csv"; read_csv(jhu_url, show_col_types = FALSE) %>% select(-c(UID, iso2, iso3, code3, FIPS, Admin2, Province_State, Country_Region, Lat, Long_, Combined_Key)) %>% pivot_longer(cols = matches("^\\d+/\\d+/\\d+$"), names_to = "Date", values_to = "Cumulative_Cases") %>% mutate(Date = mdy(Date)) %>% group_by(Date) %>% summarise(Cumulative_Cases = sum(Cumulative_Cases, na.rm = TRUE), .groups = 'drop') %>% arrange(Date) %>% mutate(Daily_New_Cases = Cumulative_Cases - lag(Cumulative_Cases, default = 0)) %>% filter(Daily_New_Cases >= 0, Date >= as.Date("2020-01-22")) %>% mutate(Active_Cases = zoo::rollsum(Daily_New_Cases, k = 14, fill = NA, align = "right")) %>% filter(!is.na(Active_Cases)) %>% mutate(Days_Since_Start = as.numeric(Date - min(Date)), Biweek_Group = floor(Days_Since_Start / 14)) %>% group_by(Biweek_Group) %>% summarise(cases = round(mean(Active_Cases, na.rm = TRUE) / 10000), .groups = 'drop') %>% filter(Biweek_Group >= 0, cases > 0) %>% mutate(time = Biweek_Group + 1) %>% select(time, cases) %>% arrange(time) %>% filter(time <= 35) })
  observe({ updateNumericInput(session, "M_burnin_m", max = input$M_m - 100); updateNumericInput(session, "M_burnin_c", max = input$M_c - 100) })
  
  run_full_analysis <- function(data, params) {
    
    sir_model <- function(time, state, parameters) {
      with(as.list(c(state, parameters)), {
        N_total <- S + I + R
        dS <- -beta * S * I / N_total
        dI <- beta * S * I / N_total - gamma * I
        dR <- gamma * I
        list(c(dS, dI, dR))
      })
    }
    
    SOLVER_METHOD <- "rk4"
    
    # 1. Least Squares (LS)
    ls_objective <- function(p) { init <- c(S = params$N - 1, I = 1, R = 0); sol <- deSolve::ode(y = init, times = data$time, func = sir_model, parms = list(beta = p[1], gamma = p[2]), method = SOLVER_METHOD); sum((data$cases - sol[, "I"])^2, na.rm = TRUE) }
    ls_result <- optim(par = c(params$beta_0, params$gamma_0), fn = ls_objective, method = "L-BFGS-B", lower = c(0.001, 0.001))
    ls_fit <- list(beta = ls_result$par[1], gamma = ls_result$par[2])
    
    smart_initial_params <- c(ls_fit$beta, ls_fit$gamma)
    
    # 2. Bootstrap (BS) - with post-hoc outlier rejection
    bs_samples <- matrix(NA, nrow = params$B, ncol = 2); colnames(bs_samples) <- c("beta", "gamma")
    
    for (i in 1:params$B) { 
      bs_data <- data[sample(1:nrow(data), replace = TRUE), ]
      bs_objective <- function(p) { init <- c(S = params$N - 1, I = 1, R = 0); sol <- deSolve::ode(y = init, times = bs_data$time, func = sir_model, parms = list(beta = p[1], gamma = p[2]), method = SOLVER_METHOD); sum((bs_data$cases - sol[, "I"])^2, na.rm = TRUE) }
      # Use a good starting point but wide bounds to allow exploration
      bs_res <- try(optim(par = smart_initial_params, fn = bs_objective, method = "L-BFGS-B", lower = c(0.001, 0.001)), silent = TRUE)
      if (!inherits(bs_res, "try-error")) bs_samples[i, ] <- bs_res$par
    }
    
    # *** FINAL ROBUST FIX: Post-hoc outlier rejection ***
    bs_samples_raw <- na.omit(bs_samples)
    
    # Identify outliers based on quantiles (e.g., remove top and bottom 1%)
    if (nrow(bs_samples_raw) > 10) { # Only apply if we have enough samples
      q_beta <- quantile(bs_samples_raw[, 1], probs = c(0.01, 0.99), na.rm = TRUE)
      q_gamma <- quantile(bs_samples_raw[, 2], probs = c(0.01, 0.99), na.rm = TRUE)
      
      good_indices <- which(
        bs_samples_raw[, 1] >= q_beta[1] & bs_samples_raw[, 1] <= q_beta[2] &
          bs_samples_raw[, 2] >= q_gamma[1] & bs_samples_raw[, 2] <= q_gamma[2]
      )
      bs_samples_cleaned <- bs_samples_raw[good_indices, , drop = FALSE]
    } else {
      bs_samples_cleaned <- bs_samples_raw
    }
    
    # All subsequent calculations use the cleaned samples
    bs_fit <- list(
      beta_mean = mean(bs_samples_cleaned[, 1]), 
      gamma_mean = mean(bs_samples_cleaned[, 2]), 
      samples = bs_samples_cleaned
    )
    
    # 3. Metropolis-Hastings (MH)
    log_likelihood <- function(p) { init <- c(S = params$N - 1, I = 1, R = 0); sol <- try(deSolve::ode(y = init, times = data$time, func = sir_model, parms = list(beta = p[1], gamma = p[2]), method = SOLVER_METHOD), silent = TRUE); if (inherits(sol, "try-error") || any(sol[, "I"] <= 0)) return(-Inf); sum(dpois(data$cases, lambda = sol[, "I"], log = TRUE), na.rm = TRUE) }
    mh_chain <- matrix(NA, nrow = params$M, ncol = 2); colnames(mh_chain) <- c("beta", "gamma")
    mh_chain[1, ] <- smart_initial_params 
    current_log_lik <- log_likelihood(mh_chain[1, ])
    for (i in 2:params$M) { 
      proposal <- mh_chain[i-1, ] + rnorm(2, 0, c(params$sd_beta, params$sd_gamma))
      if (any(proposal <= 0)) { mh_chain[i, ] <- mh_chain[i-1, ]; next }
      proposal_log_lik <- log_likelihood(proposal)
      if (is.finite(proposal_log_lik) && is.finite(current_log_lik) && runif(1) < exp(proposal_log_lik - current_log_lik)) { mh_chain[i, ] <- proposal; current_log_lik <- proposal_log_lik } else { mh_chain[i, ] <- mh_chain[i-1, ] }
    }
    mh_post_burn <- mh_chain[(params$M_burnin + 1):params$M, ]
    mh_fit <- list(beta_mean = mean(mh_post_burn[, 1]), gamma_mean = mean(mh_post_burn[, 2]), full_chain = mh_chain, post_burn_chain = mh_post_burn)
    
    # 4. Visualization
    time_seq <- seq(min(data$time), max(data$time), length.out = 100); init_state <- c(S = params$N - 1, I = 1, R = 0); n_viz_samples <- 100
    
    # Use the CLEANED bootstrap samples for visualization
    bs_viz_samples <- bs_fit$samples[sample(nrow(bs_fit$samples), min(n_viz_samples, nrow(bs_fit$samples))), , drop = FALSE]
    bs_pred_curves <- apply(bs_viz_samples, 1, function(p) deSolve::ode(y = init_state, times = time_seq, func = sir_model, parms = list(beta = p[1], gamma = p[2]), method = SOLVER_METHOD)[, "I"])
    
    mh_viz_samples <- mh_post_burn[sample(nrow(mh_post_burn), min(n_viz_samples, nrow(mh_post_burn))), , drop = FALSE]; mh_pred_curves <- apply(mh_viz_samples, 1, function(p) deSolve::ode(y = init_state, times = time_seq, func = sir_model, parms = list(beta = p[1], gamma = p[2]), method = SOLVER_METHOD)[, "I"])
    bs_ci_curves <- t(apply(bs_pred_curves, 1, quantile, probs = c(0.025, 0.975), na.rm = TRUE)); mh_ci_curves <- t(apply(mh_pred_curves, 1, quantile, probs = c(0.025, 0.975), na.rm = TRUE))
    
    list(ls = ls_fit, bs = bs_fit, mh = mh_fit, curves = list(time = time_seq, ls_I = deSolve::ode(y = init_state, times = time_seq, func = sir_model, parms = ls_fit, method = SOLVER_METHOD)[, "I"], bs_I_mean = deSolve::ode(y = init_state, times = time_seq, func = sir_model, parms = list(beta=bs_fit$beta_mean, gamma=bs_fit$gamma_mean), method = SOLVER_METHOD)[, "I"], mh_I_mean = deSolve::ode(y = init_state, times = time_seq, func = sir_model, parms = list(beta=mh_fit$beta_mean, gamma=mh_fit$gamma_mean), method = SOLVER_METHOD)[, "I"], bs_I_low = bs_ci_curves[, 1], bs_I_high = bs_ci_curves[, 2], mh_I_low = mh_ci_curves[, 1], mh_I_high = mh_ci_curves[, 2]))
  }
  
  
  observeEvent(input$add_record, {
    showNotification("Analysis started... please wait.", duration = 15, type = "message")
    measles_params <- list(N = input$N_0_m, beta_0 = input$beta_0_m, gamma_0 = input$gamma_0_m, B = input$B_m, M = input$M_m, M_burnin = input$M_burnin_m, sd_beta = input$sd_beta_m, sd_gamma = input$sd_gamma_m)
    covid_params <- list(N = input$N_0_c, beta_0 = input$beta_0_c, gamma_0 = input$gamma_0_c, B = input$B_c, M = input$M_c, M_burnin = input$M_burnin_c, sd_beta = input$sd_beta_c, sd_gamma = input$sd_gamma_c)
    m_data <- measles_data(); c_data <- covid_data()
    future_measles <- future({ run_full_analysis(m_data, measles_params) }, packages = "deSolve")
    future_covid   <- future({ run_full_analysis(c_data, covid_params) }, packages = "deSolve")
    promise_all(m = future_measles, c = future_covid) %...>% 
      (function(results) {
        values$measles_results <- results$m; values$covid_results <- results$c
        new_measles_record <- data.frame(Dataset = "Measles", LS_Beta = round(results$m$ls$beta, 4), LS_Gamma = round(results$m$ls$gamma, 4), BS_Beta = round(results$m$bs$beta_mean, 4), BS_Gamma = round(results$m$bs$gamma_mean, 4), MH_Beta = round(results$m$mh$beta_mean, 4), MH_Gamma = round(results$m$mh$gamma_mean, 4))
        new_covid_record <- data.frame(Dataset = "COVID-19", LS_Beta = round(results$c$ls$beta, 4), LS_Gamma = round(results$c$ls$gamma, 4), BS_Beta = round(results$c$bs$beta_mean, 4), BS_Gamma = round(results$c$bs$gamma_mean, 4), MH_Beta = round(results$c$mh$beta_mean, 4), MH_Gamma = round(results$c$mh$gamma_mean, 4))
        values$records <- rbind(values$records, new_measles_record, new_covid_record)
        showNotification("Analysis complete! Results updated.", type = "message")
      }) %...>%
      catch(function(error) { showNotification(paste("Error during analysis:", error$message), type = "error", duration = NULL); print(error) })
    return(NULL)
  })
  output$parameter_records <- DT::renderDataTable({ req(nrow(values$records) > 0); DT::datatable(values$records, selection = 'none', rownames = TRUE, options = list(scrollX = TRUE, pageLength = 4)) })
  
  # UPDATED render_fit_plot function 
  render_fit_plot <- function(results, data, title) {
    req(results, data)
    curves <- results$curves
    p <- plot_ly(source = title) %>%
      add_markers(data = data, x = ~time, y = ~cases, name = "Observed", marker = list(color = "black", symbol = 'circle', size = 6)) %>%
      # Bootstrap CI using add_polygons()
      add_polygons(x = ~c(curves$time, rev(curves$time)), y = ~c(curves$bs_I_high, rev(curves$bs_I_low)),
                   fillcolor = 'rgba(69, 117, 180, 0.2)', line = list(width = 0),
                   name = 'Bootstrap 95% CI', showlegend = TRUE) %>%
      # MH CI using add_polygons()
      add_polygons(x = ~c(curves$time, rev(curves$time)), y = ~c(curves$mh_I_high, rev(curves$mh_I_low)),
                   fillcolor = 'rgba(145, 191, 219, 0.2)', line = list(width = 0),
                   name = 'MH 95% CI', showlegend = TRUE) %>%
      # Add mean lines on top
      add_lines(x = curves$time, y = curves$ls_I, name = "Least Squares", line = list(color = '#d73027', width = 2)) %>%
      add_lines(x = curves$time, y = curves$bs_I_mean, name = "Bootstrap Mean", line = list(color = '#4575b4', width = 2, dash = 'dash')) %>%
      add_lines(x = curves$time, y = curves$mh_I_mean, name = "MH Mean", line = list(color = '#91bfdb', width = 2, dash = 'dot')) %>%
      layout(title = title, xaxis = list(title = "Time (Bi-weeks)"), yaxis = list(title = "Cases"), legend = list(orientation = "h", xanchor = "center", x = 0.5, y = -0.3))
    
    return(p)
  }
  
  render_mcmc_trace <- function(results, title) { req(results); chain <- as.data.frame(results$mh$full_chain); chain$Iteration <- 1:nrow(chain); p1 <- plot_ly(data=chain, x=~Iteration, y=~beta, type='scatter', mode='lines', name="&beta;"); p2 <- plot_ly(data=chain, x=~Iteration, y=~gamma, type='scatter', mode='lines', name="&gamma;"); subplot(p1, p2, nrows = 2, shareX = TRUE, titleY = TRUE) %>% layout(title = title, showlegend = FALSE) }
  render_mh_posterior <- function(results, title) { req(results); chain <- as.data.frame(results$mh$post_burn_chain); p1 <- plot_ly(data=chain, x=~beta, type='histogram', name="&beta;", marker=list(color='#91bfdb')); p2 <- plot_ly(data=chain, x=~gamma, type='histogram', name="&gamma;", marker=list(color='#91bfdb')); subplot(p1, p2, nrows = 2, titleY = TRUE) %>% layout(title = title, showlegend = FALSE, xaxis=list(title="&beta;"), xaxis2=list(title="&gamma;")) }
  render_bs_dist <- function(results, title) { req(results); samples <- as.data.frame(results$bs$samples); p1 <- plot_ly(data=samples, x=~beta, type='histogram', name="&beta;", marker=list(color='#4575b4')); p2 <- plot_ly(data=samples, x=~gamma, type='histogram', name="&gamma;", marker=list(color='#4575b4')); subplot(p1, p2, nrows = 2, titleY = TRUE) %>% layout(title = title, showlegend = FALSE, xaxis=list(title="&beta;"), xaxis2=list(title="&gamma;")) }
  output$measles_fit_plot <- renderPlotly({ render_fit_plot(values$measles_results, measles_data(), "Fit Comparison (Measles)") }); output$measles_mcmc_trace <- renderPlotly({ render_mcmc_trace(values$measles_results, "MCMC Trace (Measles)") }); output$measles_mh_posterior <- renderPlotly({ render_mh_posterior(values$measles_results, "MH Posterior (Measles)") }); output$measles_bs_dist <- renderPlotly({ render_bs_dist(values$measles_results, "Bootstrap Distribution (Measles)") })
  output$covid_fit_plot <- renderPlotly({ render_fit_plot(values$covid_results, covid_data(), "Fit Comparison (COVID-19)") }); output$covid_mcmc_trace <- renderPlotly({ render_mcmc_trace(values$covid_results, "MCMC Trace (COVID-19)") }); output$covid_mh_posterior <- renderPlotly({ render_mh_posterior(values$covid_results, "MH Posterior (COVID-19)") }); output$covid_bs_dist <- renderPlotly({ render_bs_dist(values$covid_results, "Bootstrap Distribution (COVID-19)") })
}


# 5. RUN
shinyApp(ui = ui, server = server)